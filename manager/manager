#!/usr/bin/env bash
# Script for managing submissions from the web frontend.
# Natan Zohar

# GLOBAL DEFINITIONS
INTERVAL=5 # poll interval
ROOT="/home/html-dev/under/benamy/contest" # root directory of contest dir.
TIMEOUT=30 # program execution timeout (we kill it after $TIMEOUT)
JAVABIN="/opt/java/jre/bin/java" # location of java binary to be passed to soapbox
STOP_FILE="STOP" # file to create to stop the poll.

#TODO: Declare all variables that are local at top of function.

# Bash script to run a command and find it's return code
# and if it timed out. Additionally, it uses soapbox if it is around
# to make sure programs aren't messing about with security.
bashexec(){
        local RET COMMAND ERROUT PID KPID

	#Return Codes:
	SUCCESS=0
	CRASHED=1
	TIMEDOUT=2
	SOAPED=3

	# Check if soapbox exists.
	which soapbox > /dev/null
	RET=$?
	if [[ $RET == 0 ]]; then
		SOAPBOX="soapbox -s -f -l soapbox.log ${SOAPBOXARGS}"
	else 
		SOAPBOX="" 
	fi

	COMMAND="$SOAPBOX $*"
	ERROUT=output.err

	# Run the command
	${COMMAND} 2> ${ERROUT}&
	PID=$!

        # Start the timeout timer (TIMEOUT is defined at top of file).
	sleep $TIMEOUT && kill $PID 2> /dev/null&
        KPID=$!
	# Wait for the process to end or be killed.
	wait $PID 2> /dev/null
	RET=$?
        # kill the backgrounded process if it isn't already dead
        # because it is stopping us from returning.
        kill $KPID 2> /dev/null

	#Check security on the program (perhaps it wasn't soapboxed properly)
	if ( test -s soapbox.log ); then
		return $SOAPED
	fi
	#Check for errors:
	case $RET in 
		0)  # Successfully returned.
		return $SUCCESS;;

		1) # Java exception
		if ( test -s ${ERROUT} ); then
		    return $CRASHED;
		fi
		;;

		139) # Crashed (Segfault) 
		return $CRASHED;;

		143) # Received a kill signal.
		return $TIMEDOUT;;

		*) # Default
		return $SUCCESS;;

	esac
}

# build the submitted file, (takes file.ext as an argument)
build() {
	# test existence of file we are building.
	if (! test -f $1); then
		return 
	fi
        local BFILE GCPP GCC JAVAC MCS CPPFLAGS CFLAGS CSFLAGS
        BFILE=$1
	# Declare our compilers
	GCPP="g++"
	GCC="gcc"
	JAVAC="javac"
	MCS="mcs"
	CPPFLAGS=
	CFLAGS=
	CSFLAGS=

	# Find out the file's type and set compile line.
        case ${TYPE} in
            $JAVA)
                COMPILE="${JAVAC} ${BFILE}" ;;
            $C)
                COMPILE="${GCC} ${CFLAGS} ${BFILE}" ;;
            $CPP)
                COMPILE="${GCPP} ${CPPFLAGS} ${BFILE}" ;;
            $CS)
                COMPILE="${MCS} ${CSFLAGS} ${BFILE}" ;;
            *)
                break ;;
        esac

	echo ${COMPILE}
	`${COMPILE}`
}

# Clean up the whole contest directory, i.e. move old files out into a new one.
clean() {
	DATE=`date +%F`
	# Create a directory for all the information from this contest.
	mkdir "${ROOT_DIR}/old/${DATE}" -p
	cd "${ROOT_DIR}/old/${DATE}"
	mkdir manager manager/logs submissions problems
	if [ $# == 0 ]; then
		return
	fi
}


# build and compare the problem to the test cases.
compare() {
        local FILE PROB BASE ID NAME TIME VERIFY OUTFILE LOG STATUS MESSAGE OUTPUT
	FILE=$1
        PROB=`dirname $1`
        findext ${FILE}
	BASE=`basename ${FILE}`
	while read LINE
	do
		ID=`echo ${LINE} | awk -F ':' '{print $1}'`
		NAME=`echo ${LINE} | awk -F ':' '{print $2}'`
		echo "s/${ID}/${NAME}/g"
	done < ${ROOT}/manager/conf/users.txt > user_translation.tmp
	ID=`echo ${BASE} | awk -F '-' '{print $1}'`
	NAME=`echo ${BASE} | awk -F '-' '{print $1}' | sed -f user_translation.tmp`
	rm user_translation.tmp -f
	TIME=`echo ${BASE} | awk -F '-' '{print $2}'`
	TIME=`basename ${TIME} .c`
	TIME=`basename ${TIME} .cpp`
	TIME=`basename ${TIME} .java`
	TIME=`basename ${TIME} .cs`
	VERIFY="mydiff"

	OUTFILE=output.txt

	LOG="${ROOT}/manager/logs/compiles/${BASE}.log"

	rm ${ROOT}/testing -rf
	mkdir ${ROOT}/testing/cases -p
	mkdir ${ROOT}/testing/build/home -p
	cp ${FILE}* ${ROOT}/testing/build
	cp ${ROOT}/problems/${PROB}/*output ${ROOT}/testing/cases
	cp ${ROOT}/problems/${PROB}/*input ${ROOT}/testing/cases
	cd ${ROOT}/testing/build

        case ${TYPE} in
            $JAVA)
                mv ${BASE} ${PROB}.java
                touch blankpolicyfile
                ARGS="-Djava.security.manager -Djava.security.policy=blankpolicyfile"
                EXEC="bashexec java ${ARGS} ${PROB}"
                SOAPBOXARGS="-r ${JAVABIN}"
                BASE=${PROB}.java
                ;;
            $CS)
                export MONO_SHARED_DIR=`pwd`/home
                EXEC="bashexec mono ${BASE}.exe"
                SOAPBOXARGS="-p ${MONO_SHARED_DIR}"
                ;;
            *) 
                EXEC="bashexec ./a.out"
                SOAPBOXARGS=""
                ;;
        esac

        # Build the file and send the output to the compile log.
        build ${BASE} &> ${LOG}

	if [ $? != 0 ]; then
		echo "${TIME},${ID},${NAME},${PROB},1,${LOG},Error Compiling"
		return 1	
	fi


	# Run test cases on the submission
	STATUS=0
	MESSAGE=Success
	for INPUT in ../cases/*.input; do
		OUTPUT=`basename ${INPUT} .input`.output
		OUTPUT="../cases/$OUTPUT"
		${EXEC} < ${INPUT} > ${OUTFILE}
		RET=$?
		if [ $RET == 1 ]; then
			STATUS=4
			MESSAGE="${INPUT}-Program crashed"
			break
		fi
		if [ $RET == 2 ]; then
			STATUS=3
			MESSAGE="${INPUT}-Program timed out"
			break
		fi 
		if [ $RET != 0 ]; then
			STATUS=15
			MESSAGE="${INPUT}-Unknown Error"
			break
		fi
		${VERIFY} ${OUTFILE} ${OUTPUT} > /dev/null
		RET=$?
		if [ $RET != 0 ]; then
			STATUS=2
			MESSAGE="${INPUT}-Output is not as expected"
			break
		fi
	done
	echo "${TIME},${ID},${NAME},${PROB},${STATUS},${MESSAGE}"
}

# Empty our queue of received submissions and run compare on each one.
empty_queue() {
        local QUEUE
	QUEUE=`cat queue 2>/dev/null`
	if [ $? != 0 ]; then
		return 
	fi
	for item in $QUEUE; do
		echo "Looking at $item"
		OUTPUT=`compare $item`
		echo $OUTPUT >> ${ROOT}/manager/logs/log
		echo $OUTPUT
	done

	# Move the contents of the queue to the finished pile.
	cat queue >> finished 
	rm queue -f
}

# Find the ext of passed in argument and set TYPE 
# to either JAVA, C, CPP or CS (Also set these types
# as integers, for later use.
findext() {
    local BASE
    C=0 # c
    CPP=1 # c++
    CS=2 # c#
    JAVA=3 # java
    UNKNOWN=15
    BASE=`basename $*`
    
    if [ `basename ${BASE} .java` != ${BASE} ]; then
        TYPE=${JAVA}
    elif [ `basename ${BASE} .cs` != ${BASE} ]; then
        TYPE=${MONO}
    elif [ `basename ${BASE} .cpp` != ${BASE} ]; then
        TYPE=${CPP}
    elif [ `basename ${BASE} .c` != ${BASE} ]; then
        TYPE=${C}
    else
        TYPE=${UNKNOWN} 
    fi
}

# Sit and wait for the queue to get populated.
poll() {
	DIR="${ROOT}/submissions/"
	cd ${DIR}
	rm ${STOP_FILE} -f
	if [[ $1 == "stop" ]]; then
		touch $STOP_FILE
		return 
	fi
	echo "Starting the poll"
	while (sleep $INTERVAL); do
		if (test -f ${STOP_FILE}); then
			echo "Stopping the poll program from request."
			break;
		fi
		empty_queue
	done
}

# Call our poll function with all passed arguments.
# TODO: later on, fix this, so different arguments can be passed.
poll $*
