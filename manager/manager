#!/usr/bin/env bash
# Script for managing submissions from the web frontend.
# Natan Zohar

# GLOBAL DEFINITIONS
INTERVAL=5
ROOT="/home/html-dev/under/acm/contest"
TIMEOUT=30


bashexec(){
	# Bash script to run a command and find it's return code
	# and if it timed out. Additionally, it uses soapbox if it is around
	# to make sure programs aren't messing about with security.

	#Return Codes:
	SUCCESS=0
	CRASHED=1
	TIMEDOUT=2
	SOAPED=3

	# Check if soapbox exists.
	which soapbox > /dev/null
	RET=$?
	if [[ $RET == 0 ]]; then
		SOAPBOX="soapbox -s -f -l soapbox.log"
	else 
		SOAPBOX="" 
	fi


	COMMAND="$SOAPBOX $*"
	TIMEOUT=5 # how long to let a program run
	ERROUT=output.err

	# Run the command
	${COMMAND} 2> ${ERROUT}&
	PID=$!

	# Start the timeout timer.
	sleep $TIMEOUT && kill $PID 2> /dev/null&
	# Wait for the process to end
	wait $PID 2> /dev/null
	RET=$?

	#Check security on the program (perhaps it wasn't soapboxed properly)
	if ( test -s soapbox.log ); then
		return $SOAPED
	fi

	#Check for errors:
	case $RET in 
		0)  # Successfully returned.
		return $SUCCESS;;

		1) # Java exception
		if ( test -s ${ERROUT} ); then
		    return $CRASHED;
		fi
		;;

		139) # Crashed (Segfault) 
		return $CRASHED;;

		143) # Received a kill signal.
		return $TIMEDOUT;;

		*) # Default
		return $SUCCESS;;

	esac
}

# build the submitted file, (takes file.ext as an argument)
build() {
	# test existence of file we are building.
	if (! test -f $1); then
		return 
	fi

	# Declare our compilers
	GCPP="g++"
	GCC="gcc"
	JAVAC="javac"
	MCS="mcs"
	CPPFLAGS=
	CFLAGS=
	CSFLAGS=

	# Find out the file's type:
	FILE=`basename $1`
	C=`basename ${FILE} .c`
	CPP=`basename ${FILE} .cpp`
	JAVA=`basename ${FILE} .java`
	CS=`basename ${FILE} .cs`

	if [[ ${FILE} != ${JAVA} ]]; then
		COMPILE="${JAVAC} ${FILE}"
	fi
	if [[ ${FILE} != ${C} ]]; then
		COMPILE="${GCC} ${CFLAGS} ${FILE}"
	fi
	if [[ ${FILE} != ${CPP} ]]; then
		COMPILE="${GCPP} ${CPPFLAGS} ${FILE}"
	fi
	if [[ ${FILE} != ${CS} ]]; then
		COMPILE="${MCS} ${CSFLAGS} ${FILE}"
	fi

	echo ${COMPILE}
	`${COMPILE}`
}

# Clean up the whole contest directory, i.e. move old files out into a new one.
clean() {
	DATE=`date +%F`
	# Create a directory for all the information from this contest.
	mkdir "${ROOT_DIR}/old/${DATE}" -p
	cd "${ROOT_DIR}/old/${DATE}"
	mkdir logs submissions problems
	#!/usr/bin/env bash
	if [ $# == 0 ]; then
		return
	fi
}


# build and compare the problem to the test cases.
compare() {
	FILE=$1
	PROB=`dirname $1`
	BASE=`basename ${FILE}`
	JAVA=`basename ${BASE} .java`
	MAKE=${BASE}.make
	while read LINE
	do
		ID=`echo ${LINE} | awk -F ':' '{print $1}'`
		NAME=`echo ${LINE} | awk -F ':' '{print $2}'`
		echo "s/${ID}/${NAME}/g"
	done < ${ROOT}/manager/users.txt > user_translation.tmp
	ID=`echo ${BASE} | awk -F '-' '{print $1}'`
	NAME=`echo ${BASE} | awk -F '-' '{print $1}' | sed -f user_translation.tmp`
	rm user_translation.tmp -f
	TIME=`echo ${BASE} | awk -F '-' '{print $2}'`
	TIME=`basename ${TIME} .c`
	TIME=`basename ${TIME} .cpp`
	TIME=`basename ${TIME} .java`
	TIME=`basename ${TIME} .cs`
	VERIFY="mydiff"

	OUTFILE=output.txt

	LOG="${ROOT}/logs/compiles/${BASE}.log"

	rm ${ROOT}/testing -rf
	mkdir ${ROOT}/testing/cases -p
	mkdir ${ROOT}/testing/build -p
	cp ${FILE}* ${ROOT}/testing/build
	cp ${ROOT}/problems/${PROB}/*output ${ROOT}/testing/cases
	cp ${ROOT}/problems/${PROB}/*input ${ROOT}/testing/cases
	cd ${ROOT}/testing/build

	#TODO: have it execute mono executables with mcs.
	if [ ${JAVA} != ${BASE} ]; then
		mv ${BASE} ${PROB}.java
		EXEC="bashexec java ${PROB}"
		BASE=${PROB}.java
	else
		EXEC="bashexec ./a.out"
	fi

	build ${BASE} &> ${LOG}
	#while read line; do
	#        ${line} &> ${LOG}
	#done < ${MAKE}

	if [ $? != 0 ]; then
		echo "${TIME},${ID},${NAME},${PROB},1,${LOG},Error Compiling"
		return 1	
	fi


	# Run test cases on the submission
	STATUS=0
	MESSAGE=Success
	for INPUT in ../cases/*.input; do
		OUTPUT=`basename ${INPUT} .input`.output
		OUTPUT="../cases/$OUTPUT"
		${EXEC} < ${INPUT} > ${OUTFILE}
		RET=$?
		if [ $RET == 1 ]; then
			STATUS=4
			MESSAGE="${INPUT}-Program crashed"
			break
		fi
		if [ $RET == 2 ]; then
			STATUS=3
			MESSAGE="${INPUT}-Program timed out"
			break
		fi 
		if [ $RET != 0 ]; then
			STATUS=15
			MESSAGE="${INPUT}-Unknown Error"
			break
		fi
		${VERIFY} ${OUTFILE} ${OUTPUT} > /dev/null
		RET=$?
		if [ $RET != 0 ]; then
			STATUS=2
			MESSAGE="${INPUT}-Output is not as expected"
			break
		fi
	done
	echo "${TIME},${ID},${NAME},${PROB},${STATUS},${MESSAGE}"
}

# Empty our queue of received submissions and run compare on each one.
empty_queue() {
	QUEUE=`cat queue 2>/dev/null`
	if [ $? != 0 ]; then
		return 
	fi
	for item in $QUEUE; do
		echo "Looking at $item"
		OUTPUT=`compare $item`
		echo $OUTPUT >> ../logs/log
		echo $OUTPUT
	done

	# Move the contents of the queue to the finished pile.
	cat queue >> finished 
	rm queue -f
}

# Sit and wait for the queue to get populated.
poll() {
	DIR="${ROOT}/submissions/"
	STOP_FILE="STOP"
	cd ${DIR}
	rm ${STOP_FILE} -f
	if [[ $1 == "stop" ]]; then
		touch $STOP_FILE
		return 
	fi
	echo "Starting the poll"
	while (sleep $INTERVAL); do
		if (test -f ${STOP_FILE}); then
			echo "Stopping the poll program from request."
			break;
		fi
		empty_queue
	done
}

# Call our poll function with all passed arguments.
# TODO: later on, fix this, so different arguments can be passed.
poll $*
